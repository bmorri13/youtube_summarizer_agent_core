# Main CI/CD Workflow for YouTube Analyzer
#
# Triggers:
# - Push to main: Full deployment
# - Pull requests: Plan only
# - Manual dispatch: Full deployment with options
#
# Security: Uses OIDC for keyless AWS authentication

name: Deploy

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      skip_apply:
        description: 'Skip Terraform apply (plan only)'
        type: boolean
        default: false

permissions:
  id-token: write   # Required for OIDC
  contents: read
  pull-requests: write  # For PR comments

env:
  AWS_REGION: us-east-1
  PROJECT_NAME: youtube-analyzer
  TF_VAR_anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
  TF_VAR_slack_webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
  TF_VAR_monitor_channel_urls: ${{ secrets.MONITOR_CHANNEL_URLS }}
  TF_VAR_enable_scheduled_monitoring: "false"
  TF_VAR_schedule_expression: "rate(30 minutes)"
  TF_VAR_langfuse_admin_password: ${{ secrets.LANGFUSE_ADMIN_PASSWORD }}

jobs:
  # ===========================================
  # Job 1: Terraform Plan
  # ===========================================
  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    outputs:
      plan_exit_code: ${{ steps.plan.outputs.exitcode }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Terraform Init
        working-directory: terraform
        run: terraform init

      - name: Terraform Validate
        working-directory: terraform
        run: terraform validate

      - name: Terraform Plan
        id: plan
        working-directory: terraform
        run: |
          terraform plan -detailed-exitcode -out=tfplan 2>&1 | tee plan_output.txt
          echo "exitcode=${PIPESTATUS[0]}" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Upload Plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: terraform/tfplan
          retention-days: 5

      - name: Comment PR with Plan
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const planOutput = fs.readFileSync('terraform/plan_output.txt', 'utf8');
            const truncated = planOutput.length > 60000
              ? planOutput.substring(0, 60000) + '\n\n... (truncated)'
              : planOutput;

            const body = `## Terraform Plan Output

            <details>
            <summary>Show Plan</summary>

            \`\`\`hcl
            ${truncated}
            \`\`\`

            </details>

            **Exit Code:** ${{ steps.plan.outputs.exitcode }}
            - \`0\` = No changes
            - \`2\` = Changes detected
            `;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

      - name: Plan Status
        if: steps.plan.outputs.exitcode == 1
        run: exit 1

  # ===========================================
  # Job 2: Create ECR Repository (must exist before build)
  # ===========================================
  terraform-ecr:
    name: Create ECR Repository
    runs-on: ubuntu-latest
    needs: terraform-plan
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request' && !inputs.skip_apply
    outputs:
      ecr_repository_url: ${{ steps.outputs.outputs.ecr_repository_url }}
      chatbot_ecr_repository_url: ${{ steps.outputs.outputs.chatbot_ecr_repository_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Terraform Init
        working-directory: terraform
        run: terraform init

      - name: Create ECR Repositories
        working-directory: terraform
        run: |
          terraform apply -auto-approve \
            -target=aws_ecr_repository.main \
            -target=aws_ecr_lifecycle_policy.main \
            -target=aws_ecr_repository.chatbot \
            -target=aws_ecr_lifecycle_policy.chatbot

      - name: Get ECR URLs
        working-directory: terraform
        id: outputs
        run: |
          echo "ecr_repository_url=$(terraform output -raw ecr_repository_url 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
          echo "chatbot_ecr_repository_url=$(terraform output -raw chatbot_ecr_repository_url 2>/dev/null || echo '')" >> $GITHUB_OUTPUT

  # ===========================================
  # Job 3: Build and push Docker image to ECR
  # ===========================================
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: terraform-ecr
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
      image_digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.login-ecr.outputs.registry }}/${{ env.PROJECT_NAME }}
          tags: |
            type=sha,prefix=,format=long
            type=ref,event=branch
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: false

      - name: Output image info
        run: |
          echo "## Docker Image Built" >> $GITHUB_STEP_SUMMARY
          echo "**Registry:** ${{ steps.login-ecr.outputs.registry }}" >> $GITHUB_STEP_SUMMARY
          echo "**Tags:** ${{ steps.meta.outputs.tags }}" >> $GITHUB_STEP_SUMMARY
          echo "**Digest:** ${{ steps.build.outputs.digest }}" >> $GITHUB_STEP_SUMMARY

  # ===========================================
  # Job 3b: Build and push Chatbot Docker image to ECR
  # ===========================================
  build-chatbot:
    name: Build Chatbot Image
    runs-on: ubuntu-latest
    needs: terraform-ecr
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
      image_digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.login-ecr.outputs.registry }}/${{ env.PROJECT_NAME }}-chatbot
          tags: |
            type=sha,prefix=,format=long

      - name: Build and push
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.chatbot
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=chatbot
          cache-to: type=gha,mode=max,scope=chatbot
          provenance: false

      - name: Output image info
        run: |
          echo "## Chatbot Docker Image Built" >> $GITHUB_STEP_SUMMARY
          echo "**Registry:** ${{ steps.login-ecr.outputs.registry }}" >> $GITHUB_STEP_SUMMARY
          echo "**Tags:** ${{ steps.meta.outputs.tags }}" >> $GITHUB_STEP_SUMMARY
          echo "**Digest:** ${{ steps.build.outputs.digest }}" >> $GITHUB_STEP_SUMMARY

  # ===========================================
  # Job 4: Terraform Apply (after images exist)
  # ===========================================
  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: [terraform-plan, build, build-chatbot]
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request' && !inputs.skip_apply
    outputs:
      lambda_function_name: ${{ steps.outputs.outputs.lambda_function_name }}
      ecr_repository_url: ${{ steps.outputs.outputs.ecr_repository_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Terraform Init
        working-directory: terraform
        run: terraform init

      - name: Terraform Apply
        working-directory: terraform
        run: terraform apply -auto-approve

      - name: Get Outputs
        working-directory: terraform
        id: outputs
        run: |
          echo "lambda_function_name=$(terraform output -raw lambda_function_name 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
          echo "ecr_repository_url=$(terraform output -raw ecr_repository_url 2>/dev/null || echo '')" >> $GITHUB_OUTPUT

      - name: Summary
        run: |
          echo "## Terraform Apply Complete" >> $GITHUB_STEP_SUMMARY
          echo "**Lambda Function:** ${{ steps.outputs.outputs.lambda_function_name }}" >> $GITHUB_STEP_SUMMARY

  # ===========================================
  # Job 5: Update Lambda with new image
  # ===========================================
  deploy-lambda:
    name: Deploy Lambda
    runs-on: ubuntu-latest
    needs: [build, terraform-apply]
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get ECR image URI
        id: image
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          IMAGE_URI="${ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.PROJECT_NAME }}:${{ github.sha }}"
          echo "uri=${IMAGE_URI}" >> $GITHUB_OUTPUT

      - name: Update Lambda function
        run: |
          aws lambda update-function-code \
            --function-name ${{ needs.terraform-apply.outputs.lambda_function_name }} \
            --image-uri ${{ steps.image.outputs.uri }} \
            --publish

      - name: Wait for update
        run: |
          aws lambda wait function-updated \
            --function-name ${{ needs.terraform-apply.outputs.lambda_function_name }}

      - name: Summary
        run: |
          echo "## Lambda Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "**Function:** ${{ needs.terraform-apply.outputs.lambda_function_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** ${{ steps.image.outputs.uri }}" >> $GITHUB_STEP_SUMMARY

  # ===========================================
  # Job 5b: Deploy Chatbot to ECS Fargate
  # ===========================================
  deploy-chatbot:
    name: Deploy Chatbot
    runs-on: ubuntu-latest
    needs: [build-chatbot, terraform-apply]
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to ECS
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          IMAGE_URI="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${PROJECT_NAME}-chatbot:${GITHUB_SHA}"

          # Get current task def, update image, register new revision
          TASK_DEF=$(aws ecs describe-task-definition --task-definition ${PROJECT_NAME}-chatbot --query 'taskDefinition')
          NEW_TASK_DEF=$(echo "$TASK_DEF" | jq --arg IMG "$IMAGE_URI" \
            '.containerDefinitions[0].image = $IMG | del(.taskDefinitionArn,.revision,.status,.requiresAttributes,.compatibilities,.registeredAt,.registeredBy)')
          NEW_REV=$(aws ecs register-task-definition --cli-input-json "$NEW_TASK_DEF" --query 'taskDefinition.revision' --output text)

          # Update service
          aws ecs update-service \
            --cluster ${PROJECT_NAME}-chatbot \
            --service ${PROJECT_NAME}-chatbot \
            --task-definition ${PROJECT_NAME}-chatbot:${NEW_REV}

      - name: Wait for deployment
        run: |
          aws ecs wait services-stable \
            --cluster ${PROJECT_NAME}-chatbot \
            --services ${PROJECT_NAME}-chatbot

      - name: Summary
        run: |
          echo "## Chatbot Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "**Cluster:** ${{ env.PROJECT_NAME }}-chatbot" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** ${{ env.PROJECT_NAME }}-chatbot:${{ github.sha }}" >> $GITHUB_STEP_SUMMARY

  # ===========================================
  # Job 6: Smoke Test
  # ===========================================
  smoke-test:
    name: Smoke Test
    runs-on: ubuntu-latest
    needs: [deploy-lambda, terraform-apply]
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Test Lambda invocation
        run: |
          # Invoke Lambda with a test payload
          aws lambda invoke \
            --function-name ${{ needs.terraform-apply.outputs.lambda_function_name }} \
            --payload '{"test": true}' \
            --cli-binary-format raw-in-base64-out \
            response.json

          # Check response
          cat response.json

          # Verify no error in response
          if grep -q '"errorType"' response.json; then
            echo "Lambda returned an error"
            exit 1
          fi

      - name: Summary
        run: |
          echo "## Smoke Test Results" >> $GITHUB_STEP_SUMMARY
          echo "Lambda invocation successful" >> $GITHUB_STEP_SUMMARY

  # ===========================================
  # Job 7: Deploy Fetcher to Home Server via Tailscale
  # ===========================================
  deploy-fetcher:
    name: Deploy Transcript Fetcher
    runs-on: ubuntu-latest
    needs: [terraform-apply]
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Tailscale
        uses: tailscale/github-action@v2
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:git-ci

      - name: Deploy to home server
        env:
          TS_SSH_HOST: ${{ secrets.TS_SSH_HOST }}
          TS_SSH_USER: ${{ secrets.TS_SSH_USER }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: us-east-1
          NOTES_S3_BUCKET: ${{ secrets.NOTES_S3_BUCKET }}
          MONITOR_CHANNEL_URLS: ${{ secrets.MONITOR_CHANNEL_URLS }}
          LAMBDA_FUNCTION_NAME: youtube-analyzer
        run: |
          # Create deployment directory
          ssh -o StrictHostKeyChecking=no ${TS_SSH_USER}@${TS_SSH_HOST} "mkdir -p /opt/docker/yt-transcript"

          # Copy files to remote
          scp -o StrictHostKeyChecking=no -r \
            Dockerfile.fetcher \
            docker-compose.yml \
            requirements.txt \
            local_fetcher.py \
            tools/ \
            ${TS_SSH_USER}@${TS_SSH_HOST}:/opt/docker/yt-transcript/

          # Create .env file on remote
          ssh -o StrictHostKeyChecking=no ${TS_SSH_USER}@${TS_SSH_HOST} "cat > /opt/docker/yt-transcript/.env << 'EOF'
          MONITOR_CHANNEL_URLS=${MONITOR_CHANNEL_URLS}
          AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
          AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
          AWS_REGION=${AWS_REGION}
          LAMBDA_FUNCTION_NAME=${LAMBDA_FUNCTION_NAME}
          NOTES_S3_BUCKET=${NOTES_S3_BUCKET}
          NOTES_BACKEND=s3
          EOF"

          # Build and restart container
          ssh -o StrictHostKeyChecking=no ${TS_SSH_USER}@${TS_SSH_HOST} "
            cd /opt/docker/yt-transcript && \
            docker compose build fetcher && \
            docker compose up -d fetcher
          "

      - name: Verify deployment
        env:
          TS_SSH_HOST: ${{ secrets.TS_SSH_HOST }}
          TS_SSH_USER: ${{ secrets.TS_SSH_USER }}
        run: |
          ssh -o StrictHostKeyChecking=no ${TS_SSH_USER}@${TS_SSH_HOST} "
            docker ps | grep youtube-fetcher && echo 'Fetcher container is running'
          "

      - name: Summary
        run: |
          echo "## Fetcher Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "**Host:** ${{ secrets.TS_SSH_HOST }}" >> $GITHUB_STEP_SUMMARY
          echo "**Path:** /opt/docker/yt-transcript" >> $GITHUB_STEP_SUMMARY

  # ===========================================
  # Final Summary
  # ===========================================
  summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [terraform-plan, terraform-ecr, build, build-chatbot, terraform-apply, deploy-lambda, deploy-chatbot, smoke-test, deploy-fetcher]
    if: always() && github.ref == 'refs/heads/main' && github.event_name != 'pull_request'

    steps:
      - name: Generate Summary
        run: |
          echo "# Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Terraform Plan | ${{ needs.terraform-plan.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Create ECR | ${{ needs.terraform-ecr.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Build Image | ${{ needs.build.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Build Chatbot | ${{ needs.build-chatbot.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Terraform Apply | ${{ needs.terraform-apply.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Lambda | ${{ needs.deploy-lambda.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Chatbot | ${{ needs.deploy-chatbot.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Smoke Test | ${{ needs.smoke-test.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Fetcher | ${{ needs.deploy-fetcher.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Actor:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
